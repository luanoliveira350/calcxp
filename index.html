<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Experiência Profissional</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4285F4;
            --secondary-color: #34A853;
            --danger-color: #EA4335;
            --warning-color: #FBBC05;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #333;
            --white: #ffffff;
        }

        body {
            font-family: 'Roboto', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: var(--light-gray);
            color: var(--dark-gray);
            line-height: 1.6;
        }

        h1, h2, h3 {
            color: var(--dark-gray);
            margin-top: 0;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 1.5rem;
            font-weight: 500;
            color: var(--primary-color);
        }

        h2 {
            font-size: 1.5rem;
            margin: 1.5rem 0 1rem;
            font-weight: 500;
        }

        .container {
            background-color: var(--white);
            padding: 2rem;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        th, td {
            border: 1px solid var(--medium-gray);
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: var(--primary-color);
            color: var(--white);
            font-weight: 500;
        }

        tr:nth-child(even) {
            background-color: var(--light-gray);
        }

        tr:hover {
            background-color: rgba(66, 133, 244, 0.1);
        }

        .total-row {
            font-weight: 500;
            background-color: rgba(52, 168, 83, 0.2) !important;
        }

        .input-group {
            margin-bottom: 1.2rem;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
        }

        .input-group label {
            min-width: 120px;
            font-weight: 500;
        }

        input[type="date"], input[type="text"] {
            padding: 10px 12px;
            border: 1px solid var(--medium-gray);
            border-radius: 6px;
            font-family: 'Roboto', sans-serif;
            flex: 1;
            min-width: 150px;
            max-width: 200px;
        }

        button {
            padding: 10px 18px;
            background-color: var(--primary-color);
            color: var(--white);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Roboto', sans-serif;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        button:hover {
            background-color: #3367d6;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .remove-btn {
            background-color: var(--danger-color);
        }

        .remove-btn:hover {
            background-color: #d33426;
        }

        .period-list {
            margin-bottom: 2rem;
        }

        .period-item {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 10px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 8px;
            gap: 10px;
        }

        .invalid {
            color: var(--danger-color);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-left: 10px;
        }

        .checkbox-group label {
            margin-left: 8px;
            white-space: nowrap;
        }

        /* Estilos para o gráfico de barras */
        .timeline-chart {
            margin: 2rem 0;
            position: relative;
            height: auto;
            min-height: 300px;
            border-left: 2px solid var(--dark-gray);
            padding-left: 15px;
        }

        .chart-period {
            position: absolute;
            height: 30px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border-radius: 4px;
        }

        .chart-period:hover {
            opacity: 0.9;
            transform: scaleY(1.05);
        }

        .chart-period.valid {
            background-color: var(--primary-color);
        }

        .chart-period.invalid {
            background-color: var(--danger-color);
        }

        .chart-period.consolidated {
            background-color: var(--secondary-color);
        }

        .chart-label {
            position: absolute;
            white-space: nowrap;
            font-size: 12px;
            font-weight: 500;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: var(--dark-gray);
        }

        .chart-label.top {
            bottom: 100%;
            left: 0;
            margin-bottom: 5px;
        }

        .chart-label.bottom {
            top: 100%;
            left: 0;
            margin-top: 5px;
        }

        .chart-date-axis {
            position: absolute;
            bottom: -30px;
            left: 0;
            width: 100%;
            height: 20px;
            border-top: 1px solid var(--medium-gray);
        }

        .chart-date-tick {
            position: absolute;
            top: 0;
            width: 1px;
            height: 5px;
            background-color: var(--dark-gray);
        }

        .chart-date-label {
            position: absolute;
            top: 6px;
            font-size: 11px;
            transform: translateX(-50%);
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            margin: 1.5rem 0;
            flex-wrap: wrap;
            gap: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background-color: var(--light-gray);
            border-radius: 20px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            border-radius: 3px;
        }

        /* Estilo para a marcação da data de formação */
        .formation-marker {
            position: absolute;
            left: 0;
            width: 2px;
            height: 100%;
            background-color: #FBBC05;
            z-index: 10;
        }

        .formation-label {
            position: absolute;
            left: 5px;
            background-color: #FBBC05;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .container {
                padding: 1.2rem;
            }

            .input-group {
                flex-direction: column;
                align-items: flex-start;
            }

            .input-group label {
                margin-bottom: 5px;
            }

            input[type="date"], input[type="text"] {
                max-width: 100%;
                width: 100%;
            }

            .period-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .chart-label {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Calculadora de Experiência Profissional</h1>
        <div>⚠️ Importante! Esta calculadora é uma ferramenta de apoio e deve ser validada pela comissão organizadora do SEREP-BR antes de seu uso oficial. Consulte a comissão para garantir a conformidade.</div>
        <div>⚠️ Importante! Não esquecer de somar o resultado da experiência profissional com a formação acadêmica.</div>
        <div class="input-group">
            <label for="formation-date">Data de Formação:</label>
            <input type="date" id="formation-date">
        </div>

        <div class="input-group">
            <label for="position-name">Cargo:</label>
            <input type="text" id="position-name" placeholder="Digite o nome do cargo">

            <label for="start-date">Data Início:</label>
            <input type="date" id="start-date">

            <label for="end-date">Data Fim:</label>
            <input type="date" id="end-date">

            <div class="checkbox-group">
                <input type="checkbox" id="open-period">
                <label for="open-period">Em aberto (23/04/2025)</label>
            </div>

            <button id="add-period">Adicionar Período</button>
        </div>

        <div class="period-list" id="periods-container">
            <h2>Períodos de Experiência</h2>
            <!-- Períodos serão adicionados aqui dinamicamente -->
        </div>

        <button id="calculate">Calcular</button>

        <div id="result-container" style="display: none;">
            <h2>Resultado</h2>
            <table id="result-table">
                <thead>
                    <tr>
                        <th>Cargo</th>
                        <th>Período</th>
                        <th>Dias</th>
                        <th>Nota Máxima</th>
                        <th>Períodos de 180 dias</th>
                        <th>Nota Total</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Resultados serão adicionados aqui dinamicamente -->
                </tbody>
            </table>
        </div>

        <div id="timeline-container" style="display: none;">
            <h2>Visualização da Linha do Tempo</h2>

            <div class="chart-legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4285F4;"></div>
                    <span>Períodos Válidos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #EA4335;"></div>
                    <span>Períodos Inválidos</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #34A853;"></div>
                    <span>Períodos Consolidados</span>
                </div>
            </div>

            <div class="timeline-chart" id="timeline-chart">
                <!-- Gráfico de barras será renderizado aqui -->
            </div>

            <h2>Linha do Tempo dos Períodos Originais</h2>
            <div class="timeline" id="original-timeline">
                <!-- Linha do tempo original será adicionada aqui -->
            </div>

            <h2>Linha do Tempo Consolidada</h2>
            <div class="timeline" id="consolidated-timeline">
                <!-- Linha do tempo consolidada será adicionada aqui -->
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const formationDateInput = document.getElementById('formation-date');
            const positionNameInput = document.getElementById('position-name');
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
            const openPeriodCheckbox = document.getElementById('open-period');
            const addPeriodBtn = document.getElementById('add-period');
            const calculateBtn = document.getElementById('calculate');
            const periodsContainer = document.getElementById('periods-container');
            const resultContainer = document.getElementById('result-container');
            const resultTable = document.getElementById('result-table').querySelector('tbody');
            const originalTimeline = document.getElementById('original-timeline');
            const consolidatedTimeline = document.getElementById('consolidated-timeline');
            const timelineContainer = document.getElementById('timeline-container');
            const timelineChart = document.getElementById('timeline-chart');

            let periods = [];

            // Função auxiliar para criar um objeto Date a partir de uma string 'YYYY-MM-DD'
            // garantindo que seja interpretado no fuso horário local e evitando o problema de "um dia a menos".
            function createLocalDate(dateString) {
                const [year, month, day] = dateString.split('-').map(Number);
                return new Date(year, month - 1, day); // month - 1 porque os meses são baseados em zero (0-11)
            }

            // Adicionar período
            addPeriodBtn.addEventListener('click', function() {
                const positionName = positionNameInput.value || 'Dev1';
                const startDateStr = startDateInput.value;
                let endDateStr = endDateInput.value;

                if (openPeriodCheckbox.checked) {
                    endDateStr = '2025-04-23'; // Data fixa para períodos em aberto
                }

                if (!startDateStr || !endDateStr) {
                    // Usar um modal personalizado em vez de alert()
                    showMessageBox('Por favor, preencha ambas as datas.');
                    return;
                }

                const startDate = createLocalDate(startDateStr);
                const endDate = createLocalDate(endDateStr);

                if (endDate < startDate) {
                    // Usar um modal personalizado em vez de alert()
                    showMessageBox('A data de fim não pode ser anterior à data de início.');
                    return;
                }

                periods.push({
                    positionName,
                    startDate: startDateStr, // Armazenar a string original para exibição
                    endDate: endDateStr,     // Armazenar a string original para exibição
                    isOpen: openPeriodCheckbox.checked
                });
                updatePeriodsList();

                // Limpar inputs
                positionNameInput.value = '';
                startDateInput.value = '';
                endDateInput.value = '';
                openPeriodCheckbox.checked = false;
            });

            // Atualizar lista de períodos
            function updatePeriodsList() {
                periodsContainer.innerHTML = '<h2>Períodos de Experiência</h2>';

                periods.forEach((period, index) => {
                    const periodDiv = document.createElement('div');
                    periodDiv.className = 'period-item';

                    const positionLabel = document.createElement('label');
                    positionLabel.textContent = 'Cargo:';

                    const positionInput = document.createElement('input');
                    positionInput.type = 'text';
                    positionInput.value = period.positionName;
                    positionInput.style.minWidth = '150px';
                    positionInput.addEventListener('change', function() {
                        periods[index].positionName = this.value;
                    });

                    const startLabel = document.createElement('label');
                    startLabel.textContent = 'Data Início:';

                    const startInput = document.createElement('input');
                    startInput.type = 'date';
                    startInput.value = period.startDate;
                    startInput.addEventListener('change', function() {
                        periods[index].startDate = this.value;
                    });

                    const endLabel = document.createElement('label');
                    endLabel.textContent = 'Data Fim:';

                    const endInput = document.createElement('input');
                    endInput.type = 'date';
                    endInput.value = period.endDate;
                    endInput.disabled = period.isOpen;
                    endInput.addEventListener('change', function() {
                        periods[index].endDate = this.value;
                    });

                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'checkbox-group';

                    const checkboxInput = document.createElement('input');
                    checkboxInput.type = 'checkbox';
                    checkboxInput.checked = period.isOpen;
                    checkboxInput.id = `open-period-${index}`;
                    checkboxInput.addEventListener('change', function() {
                        periods[index].isOpen = this.checked;
                        if (this.checked) {
                            periods[index].endDate = '2025-04-23';
                            endInput.value = '2025-04-23';
                            endInput.disabled = true;
                        } else {
                            endInput.disabled = false;
                        }
                    });

                    const checkboxLabel = document.createElement('label');
                    checkboxLabel.textContent = 'Em aberto (23/04/2025)';
                    checkboxLabel.htmlFor = `open-period-${index}`;

                    checkboxDiv.appendChild(checkboxInput);
                    checkboxDiv.appendChild(checkboxLabel);

                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'Remover';
                    removeBtn.className = 'remove-btn';
                    removeBtn.addEventListener('click', function() {
                        periods.splice(index, 1);
                        updatePeriodsList();
                    });

                    periodDiv.appendChild(positionLabel);
                    periodDiv.appendChild(positionInput);
                    periodDiv.appendChild(startLabel);
                    periodDiv.appendChild(startInput);
                    periodDiv.appendChild(endLabel);
                    periodDiv.appendChild(endInput);
                    periodDiv.appendChild(checkboxDiv);
                    periodDiv.appendChild(removeBtn);

                    periodsContainer.appendChild(periodDiv);
                });
            }

            // Calcular experiência
            calculateBtn.addEventListener('click', function() {
                if (periods.length === 0) {
                    // Usar um modal personalizado em vez de alert()
                    showMessageBox('Adicione pelo menos um período para calcular.');
                    return;
                }

                if (!formationDateInput.value) {
                    // Usar um modal personalizado em vez de alert()
                    showMessageBox('Por favor, informe a data de formação.');
                    return;
                }

                const formationDate = createLocalDate(formationDateInput.value);

                // Ordenar períodos por data de início
                periods.sort((a, b) => createLocalDate(a.startDate) - createLocalDate(b.startDate));

                // Processar períodos (aplicando as regras de ajuste)
                const processedPeriods = periods.map(period => {
                    let startDate = createLocalDate(period.startDate);
                    let endDate = createLocalDate(period.endDate);

                    // Ajustar início se começar antes da formação mas terminar depois
                    if (startDate < formationDate && endDate >= formationDate) {
                        startDate = new Date(formationDate); // Cria uma nova instância para não modificar a original
                    }

                    // Calcular dias considerando a data final inclusiva
                    // Adicionamos 1 dia para incluir o dia final no cálculo
                    const days = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;

                    // Verificar se o período é inválido
                    const isBeforeFormation = createLocalDate(period.endDate) < formationDate;
                    const isLessThan180 = days < 180;

                    // Verificar se está completamente dentro de outro período (experiência simultânea)
                    let isSimultaneous = false;
                    for (const otherPeriod of periods) {
                        if (period !== otherPeriod &&
                            createLocalDate(period.startDate) >= createLocalDate(otherPeriod.startDate) &&
                            createLocalDate(period.endDate) <= createLocalDate(otherPeriod.endDate)) {
                            isSimultaneous = true;
                            break;
                        }
                    }

                    const isValid = !isBeforeFormation && !isLessThan180 && !isSimultaneous;
                    const invalidationCode = isBeforeFormation ? 'A9' : (isLessThan180 ? 'A11' : (isSimultaneous ? 'A19' : null));

                    return {
                        ...period,
                        originalStartDate: period.startDate,
                        originalEndDate: period.endDate,
                        startDate: startDate.toISOString().split('T')[0], // Armazenar como string 'YYYY-MM-DD'
                        endDate: endDate.toISOString().split('T')[0],     // Armazenar como string 'YYYY-MM-DD'
                        days,
                        isBeforeFormation,
                        isLessThan180,
                        isSimultaneous,
                        isValid,
                        invalidationCode
                    };
                });

                // Consolidar períodos (sobrepostos ou contíguos)
                const consolidatedPeriods = consolidatePeriods(processedPeriods.filter(p => p.isValid));

                // Calcular resultados
                const results = [];
                let totalNote = 0;

                // Adicionar períodos consolidados
                consolidatedPeriods.forEach(period => {
                    const days = Math.floor((createLocalDate(period.endDate) - createLocalDate(period.startDate)) / (1000 * 60 * 60 * 24)) + 1;
                    const fullPeriods = Math.floor(days / 180);
                    const note = fullPeriods * 3.5;
                    totalNote += note;

                    results.push({
                        position: period.positionName,
                        period: `Período Consolidado: ${formatDate(period.startDate)} - ${formatDate(period.endDate)}`,
                        days: days,
                        maxNote: 3.5,
                        fullPeriods: fullPeriods,
                        totalNote: note.toFixed(2),
                        isConsolidated: true
                    });
                });

                // Adicionar períodos avulsos válidos que não foram consolidados
                const validPeriods = processedPeriods.filter(p => p.isValid);
                validPeriods.forEach(period => {
                    // Verificar se o período não está incluído em nenhum período consolidado
                    const isIncludedInConsolidated = consolidatedPeriods.some(consolidated =>
                        createLocalDate(period.startDate) >= createLocalDate(consolidated.startDate) &&
                        createLocalDate(period.endDate) <= createLocalDate(consolidated.endDate)
                    );

                    if (!isIncludedInConsolidated) {
                        const fullPeriods = Math.floor(period.days / 180);
                        const note = fullPeriods * 3.5;
                        totalNote += note;

                        results.push({
                            position: period.positionName,
                            period: `${formatDate(period.startDate)} - ${formatDate(period.endDate)}`,
                            days: period.days,
                            maxNote: 3.5,
                            fullPeriods: fullPeriods,
                            totalNote: note.toFixed(2),
                            isConsolidated: false
                        });
                    }
                });

                // Exibir resultados
                displayResults(results, totalNote, processedPeriods, consolidatedPeriods);

                // Renderizar gráfico de barras
                renderTimelineChart(processedPeriods, consolidatedPeriods);
            });

            // Consolidar períodos sobrepostos ou contíguos
            function consolidatePeriods(validPeriods) {
                if (validPeriods.length === 0) return [];

                const sortedPeriods = [...validPeriods].sort((a, b) => createLocalDate(a.startDate) - createLocalDate(b.startDate));
                const consolidated = [];

                let current = { ...sortedPeriods[0] };

                for (let i = 1; i < sortedPeriods.length; i++) {
                    const next = sortedPeriods[i];
                    const currentEnd = createLocalDate(current.endDate);
                    const nextStart = createLocalDate(next.startDate);
                    const nextEnd = createLocalDate(next.endDate);

                    // Verifica se os períodos são sobrepostos ou contíguos (até 1 dia de diferença)
                    // Adiciona um dia à data final do período atual para considerar contiguidade
                    if (nextStart <= new Date(currentEnd.getTime() + 86400000)) { // 86400000 ms = 1 dia
                        // Períodos sobrepostos ou contíguos - consolidar
                        if (nextEnd > currentEnd) {
                            current.endDate = next.endDate;
                        }
                        // Manter o nome do cargo do período mais longo
                        if ((nextEnd - nextStart) >
                            (createLocalDate(current.endDate) - createLocalDate(current.startDate))) {
                            current.positionName = next.positionName;
                        }
                    } else {
                        // Período separado - adicionar o atual e começar um novo
                        consolidated.push({ ...current });
                        current = { ...next };
                    }
                }

                // Adicionar o último período consolidado
                consolidated.push({ ...current });

                return consolidated;
            }

            // Renderizar gráfico de barras da linha do tempo
            function renderTimelineChart(processedPeriods, consolidatedPeriods) {
                timelineChart.innerHTML = '';

                // Encontrar a data mais antiga e mais recente para dimensionar o gráfico
                const allPeriods = [...processedPeriods, ...consolidatedPeriods];
                if (allPeriods.length === 0) return;

                // Usar as datas originais para o cálculo do range
                let minDate = new Date(Math.min(...allPeriods.map(p => createLocalDate(p.originalStartDate).getTime())));
                let maxDate = new Date(Math.max(...allPeriods.map(p => createLocalDate(p.originalEndDate).getTime())));

                // Adicionar margem de 3 meses antes e depois
                minDate = new Date(minDate.getFullYear(), minDate.getMonth() - 3, 1);
                maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth() + 3, 1);

                const totalMs = maxDate - minDate;
                const chartWidth = timelineChart.offsetWidth;

                // Função para converter data em posição horizontal
                const dateToPosition = (dateString) => {
                    const dateObj = createLocalDate(dateString);
                    const msFromStart = dateObj - minDate;
                    return (msFromStart / totalMs) * chartWidth;
                };

                // Adicionar marcação da data de formação
                if (formationDateInput.value) {
                    const formationDate = createLocalDate(formationDateInput.value);
                    const formationPos = dateToPosition(formationDateInput.value); // Usar a string para dateToPosition

                    const marker = document.createElement('div');
                    marker.className = 'formation-marker';
                    marker.style.left = `${formationPos}px`;
                    timelineChart.appendChild(marker);

                    const label = document.createElement('div');
                    label.className = 'formation-label';
                    label.textContent = `Formação: ${formatDate(formationDateInput.value)}`;
                    label.style.top = '10px';
                    label.style.left = `${formationPos + 5}px`;
                    timelineChart.appendChild(label);
                }

                // Adicionar eixo de datas
                const dateAxis = document.createElement('div');
                dateAxis.className = 'chart-date-axis';
                timelineChart.appendChild(dateAxis);

                // Adicionar marcadores de data
                const currentYear = minDate.getFullYear();
                const endYear = maxDate.getFullYear();

                for (let year = currentYear; year <= endYear; year++) {
                    for (let month = 0; month < 12; month++) {
                        const date = new Date(year, month, 1); // Cria uma data local para o mês
                        if (date < minDate) continue;
                        if (date > maxDate) break;

                        const position = dateToPosition(date.toISOString().split('T')[0]); // Passar como string 'YYYY-MM-DD'

                        const tick = document.createElement('div');
                        tick.className = 'chart-date-tick';
                        tick.style.left = `${position}px`;
                        dateAxis.appendChild(tick);

                        if (month === 0) {
                            const label = document.createElement('div');
                            label.className = 'chart-date-label';
                            label.textContent = year;
                            label.style.left = `${position}px`;
                            dateAxis.appendChild(label);
                        }
                    }
                }

                // Renderizar períodos originais
                processedPeriods.forEach((period, index) => {
                    // Cálculo CORRETO da posição e largura
                    const startPos = dateToPosition(period.originalStartDate);
                    const endPos = dateToPosition(period.originalEndDate);
                    const width = endPos - startPos;

                    const bar = document.createElement('div');
                    bar.className = `chart-period ${period.isValid ? 'valid' : 'invalid'}`;
                    bar.style.left = `${startPos}px`;
                    bar.style.width = `${width > 0 ? width : 5}px`; // Largura mínima de 5px
                    bar.style.top = `${index * 40}px`;

                    const topLabel = document.createElement('div');
                    topLabel.className = 'chart-label top';
                    topLabel.textContent = `${period.positionName}: ${period.days} dias`;
                    if (!period.isValid) {
                        if (period.isBeforeFormation) {
                            topLabel.textContent += ' (A9)';
                        } else if (period.isLessThan180) {
                            topLabel.textContent += ' (A11)';
                        } else if (period.isSimultaneous) {
                            topLabel.textContent += ' (A19)';
                        }
                    }
                    bar.appendChild(topLabel);

                    const bottomLabel = document.createElement('div');
                    bottomLabel.className = 'chart-label bottom';
                    bottomLabel.textContent = `${formatDate(period.originalStartDate)} - ${formatDate(period.originalEndDate)}`;
                    if (period.isOpen) {
                        bottomLabel.textContent += ' (Em aberto)';
                    }
                    bar.appendChild(bottomLabel);

                    timelineChart.appendChild(bar);
                });

                // Renderizar períodos consolidados
                const consolidatedStartY = processedPeriods.length * 40 + 50;

                consolidatedPeriods.forEach((period, index) => {
                    // Cálculo CORRETO da posição e largura
                    const startPos = dateToPosition(period.startDate);
                    const endPos = dateToPosition(period.endDate);
                    const width = endPos - startPos;

                    const days = Math.floor((createLocalDate(period.endDate) - createLocalDate(period.startDate)) / (1000 * 60 * 60 * 24)) + 1;

                    const bar = document.createElement('div');
                    bar.className = 'chart-period consolidated';
                    bar.style.left = `${startPos}px`;
                    bar.style.width = `${width > 0 ? width : 5}px`; // Largura mínima de 5px
                    bar.style.top = `${consolidatedStartY + index * 40}px`;

                    const topLabel = document.createElement('div');
                    topLabel.className = 'chart-label top';
                    topLabel.textContent = `${period.positionName} (Consolidado): ${days} dias`;
                    bar.appendChild(topLabel);

                    const bottomLabel = document.createElement('div');
                    bottomLabel.className = 'chart-label bottom';
                    bottomLabel.textContent = `${formatDate(period.startDate)} - ${formatDate(period.endDate)}`;
                    bar.appendChild(bottomLabel);

                    timelineChart.appendChild(bar);
                });
            }

            // Exibir resultados
            function displayResults(results, totalNote, processedPeriods, consolidatedPeriods) {
                // Limpar tabela de resultados
                resultTable.innerHTML = '';

                // Adicionar resultados à tabela
                results.forEach(result => {
                    const row = document.createElement('tr');

                    const positionCell = document.createElement('td');
                    positionCell.textContent = result.position;
                    row.appendChild(positionCell);

                    const periodCell = document.createElement('td');
                    periodCell.textContent = result.period;
                    row.appendChild(periodCell);

                    const daysCell = document.createElement('td');
                    daysCell.textContent = result.days;
                    row.appendChild(daysCell);

                    const maxNoteCell = document.createElement('td');
                    maxNoteCell.textContent = result.maxNote;
                    row.appendChild(maxNoteCell);

                    const fullPeriodsCell = document.createElement('td');
                    fullPeriodsCell.textContent = result.fullPeriods;
                    row.appendChild(fullPeriodsCell);

                    const totalNoteCell = document.createElement('td');
                    totalNoteCell.textContent = result.totalNote;
                    row.appendChild(totalNoteCell);

                    resultTable.appendChild(row);
                });

                // Adicionar linha de total
                if (results.length > 0) {
                    const totalRow = document.createElement('tr');
                    totalRow.className = 'total-row';

                    const totalLabelCell = document.createElement('td');
                    totalLabelCell.colSpan = 5;
                    totalLabelCell.textContent = 'Total Geral';
                    totalRow.appendChild(totalLabelCell);

                    const totalNoteCell = document.createElement('td');
                    totalNoteCell.textContent = totalNote.toFixed(2);
                    totalRow.appendChild(totalNoteCell);

                    resultTable.appendChild(totalRow);
                }

                // Exibir linha do tempo original
                originalTimeline.innerHTML = '';
                processedPeriods.forEach((period, index) => {
                    const item = document.createElement('div');
                    item.className = `timeline-item ${period.isValid ? '' : 'invalid-timeline'}`;

                    const periodText = document.createElement('span');
                    periodText.textContent = `${period.positionName} (${formatDate(period.originalStartDate)} a ${formatDate(period.originalEndDate)}) - ${period.days} dias`;
                    if (period.isOpen) {
                        periodText.textContent += ' (Em aberto)';
                    }
                    if (!period.isValid) {
                        periodText.className = 'invalid';

                        if (period.isBeforeFormation) {
                            periodText.textContent += ' - Inválido (A9 - Antes da formação)';
                        } else if (period.isLessThan180) {
                            periodText.textContent += ' - Inválido (A11 - Menos de 180 dias)';
                        } else if (period.isSimultaneous) {
                            periodText.textContent += ' - Inválido (A19 - Experiência simultânea)';
                        }
                    } else if (period.originalStartDate !== period.startDate) {
                        periodText.textContent += ` - Ajustado para: ${formatDate(period.startDate)}`;
                    }

                    item.appendChild(periodText);
                    originalTimeline.appendChild(item);
                });

                // Exibir linha do tempo consolidada
                consolidatedTimeline.innerHTML = '';
                consolidatedPeriods.forEach((period, index) => {
                    const item = document.createElement('div');
                    item.className = 'timeline-item';

                    const days = Math.floor((createLocalDate(period.endDate) - createLocalDate(period.startDate)) / (1000 * 60 * 60 * 24)) + 1;

                    const periodText = document.createElement('span');
                    periodText.textContent = `Período Consolidado ${index + 1}: ${period.positionName} (${formatDate(period.startDate)} a ${formatDate(period.endDate)}) - ${days} dias`;

                    item.appendChild(periodText);
                    consolidatedTimeline.appendChild(item);
                });

                // Mostrar containers de resultado e linha do tempo
                resultContainer.style.display = 'block';
                timelineContainer.style.display = 'block';
            }

            // Formatar data para exibição
            function formatDate(dateString) {
                // Parse the date string components to create a local date
                const [year, month, day] = dateString.split('-').map(Number);
                const date = new Date(year, month - 1, day); // month - 1 because months are 0-indexed in Date objects

                const formattedDay = date.getDate().toString().padStart(2, '0');
                const formattedMonth = (date.getMonth() + 1).toString().padStart(2, '0');
                const formattedYear = date.getFullYear();
                return `${formattedDay}/${formattedMonth}/${formattedYear}`;
            }

            // Função para exibir uma caixa de mensagem personalizada (substituindo alert)
            function showMessageBox(message) {
                // Cria um elemento div para o modal
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '50%';
                modal.style.left = '50%';
                modal.style.transform = 'translate(-50%, -50%)';
                modal.style.backgroundColor = 'white';
                modal.style.padding = '20px';
                modal.style.borderRadius = '8px';
                modal.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
                modal.style.zIndex = '1000';
                modal.style.textAlign = 'center';
                modal.style.maxWidth = '300px';
                modal.style.fontFamily = 'Roboto, sans-serif';

                // Cria um elemento para o texto da mensagem
                const messageText = document.createElement('p');
                messageText.textContent = message;
                messageText.style.marginBottom = '20px';
                modal.appendChild(messageText);

                // Cria um botão de fechar
                const closeButton = document.createElement('button');
                closeButton.textContent = 'OK';
                closeButton.style.padding = '10px 20px';
                closeButton.style.backgroundColor = 'var(--primary-color)';
                closeButton.style.color = 'white';
                closeButton.style.border = 'none';
                closeButton.style.borderRadius = '6px';
                closeButton.style.cursor = 'pointer';
                closeButton.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });
                modal.appendChild(closeButton);

                // Cria um overlay para o fundo
                const overlay = document.createElement('div');
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                overlay.style.zIndex = '999';
                overlay.addEventListener('click', () => {
                    document.body.removeChild(modal);
                    document.body.removeChild(overlay);
                });

                document.body.appendChild(overlay);
                document.body.appendChild(modal);
            }
        });
    </script>
</body>
</html>
